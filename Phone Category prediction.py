# -*- coding: utf-8 -*-
"""Applai_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uFnVAUneQlP70gKXMZsxLQ3R5Cv-Kpyc

**Applai Project**
"""

# Commented out IPython magic to ensure Python compatibility.
#import libraries
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import HTML
import seaborn as sns
import numpy as np
from scipy.stats import pearsonr

# Lets the plots appears in the notebook
# %matplotlib inline

"""**Read the file**"""

phones = pd.read_csv('Applais_project.csv')

#get the first five rows
phones.head()
#phones.head(10) => to get first ten rows

#how many entries there are.
phones.info()

#some statistics for the data
phones.describe()

#dimensions of the dataframe
phones.shape

#check for NA values in dataset
print (phones.isnull().sum())

#checking the % of NAs columnwise
phones.isnull().sum()*100/phones.shape[0]

# Cleaning Data & Handling Missing Values
#phones.dropna()
#Nearly 17% of data is missing, can't risk losing all of the data, so replacing the null values with average age will be a suitable solution.
phones['mobile_wt'].fillna( phones['mobile_wt'].median() , inplace=True)

phones.info()

X_phones =  phones.drop(columns = ['px_height'],axis=1)
y_phones = phones.px_height

def sigmoid(input):
    output = 1 / (1 + np.exp(-input))
    return output

def costFunction(theta, X, y):
    m = y.shape[0]  
    J = 0
    h = sigmoid(np.dot(X, theta))
    J = (1/m) * (np.sum(-y*np.log(h) - (1-y) * np.log(1-h),axis=0))
    return J

def gradientDecsent(iterations, alpha, x, y):
    m = x.shape[0]
    x = np.append(np.ones((x.shape[0],1)),x,axis=1)     
    y = y.to_numpy()
    print(y.shape)
    y = np.reshape(y, (len(y),1))
    print(y.shape)
    theta=np.ones((x.shape[1],1))
    cost_history = []
    for i in range(iterations):
        h=sigmoid(np.dot(x,theta))
        theta = theta - np.transpose(((alpha / m) *((h - y).T).dot(x)))
        

        cost_history.append(costFunction(theta, x, y))
    return theta, cost_history

theta, cost_history = gradientDecsent(20000, 0.002, X_phones, y_phones)

Data = np.genfromtxt(r'Applais_project.csv', delimiter=',')
iterations = 100

X = np.array(Data[:,0])
Y = np.array(Data[:,1])
X = X.reshape(X.shape[0],-1)
Y = Y.reshape(Y.shape[0],-1)
X = phones['sc_w']
Y = phones['sc_h']

print(X.shape)
print(Y.shape)

plt.figure(figsize=(6, 6))
plt.plot(X, Y, 'ro', ms=12, mec='k')
plt.title("Data")
plt.xlabel('px_height')
plt.ylabel('px_width')
plt.grid(True)

def Predictive_Line(X, Theta):

    Predictions = None
    X = np.append(np.ones((1,X.shape[0])), X.reshape((1,X.shape[0])), axis = 0)
    Predictions = np.dot(Theta.T, X)

  
    Predictions = Predictions.T
    return Predictions

np.corrcoef(X,Y)

F = Predictive_Line(X,Theta = np.array([955, 0.4]).reshape((2,1)))
print(F)

plt.figure(figsize=(6, 6))
plt.plot(X, Y, 'ro', ms=8, mec='k')
plt.title("Data")
plt.xlabel('House Size')
plt.ylabel('Price in (K) L.E')
plt.grid(False)
plt.plot(X, P, '-')
plt.legend(['Training data', 'Predictive Line']);

